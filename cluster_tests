//      Cluster Test Code

/*  Default Constructor
 *  assigns size to 0, head points to null
 */

    Cluster c1;
    cout << c1 << endl;         // prints size as 0 , no points printed

/*  add()
 * adds points to a cluster, increases size by 1 each time
 */

    double A1[3] = {2,4,6};
    Point a1(3,A1);
    PointPtr a1p = &a1;

    double B1[3] = {0,3,0};
    Point b1(3,B1);
    PointPtr b1p = &b1;

    c1.add(a1p);
    c1.add(b1p);

    cout << c1 << endl;        // size 2, 3 dimensions, ( 0 3 0 ) ( 2 4 6)

/*  Copy Constructor
 * copies size and data of existing cluster
 */

    Cluster c2(c1);

    cout << c2 << endl;         // should print out size of 2, and points (0 3 0) ( 2 4 6)

/*  Assignment Operator
 * deletes any data that may exist in lhs cluster and reassigns it the data
 * of rhs Cluster
 *
 * Case 1:  Self Assignment
 *          prevents self assignment by just returning the rhs cluster
 *
 *Case 2:   Legal Self assignment of two distinct clusters
 */

    Cluster c3 = c1;            // c3 will has size 2, 3 dimensions , ( 0 3 0 ) ( 2 4 6)
    cout << c3 << endl;

    double D1[3] = {5,5,0};
    Point d1(3,D1);
    PointPtr d1p = &d1;

    double E1[3] = {7,0,0};
    Point e1(3,E1);
    PointPtr e1p = &e1;

    c3.add(d1p);
    c3.add(e1p);
                                // c3 now has size 4, 3 dimensions , points in lexicographic order
                                // (0 3 0) ( 2 4 6) (5 5 0) ( 7 0 0)
    cout << c3;


/*  remove()
 *  removes Point from cluster, returns its address so it can be added to another Cluster
 */

    c3.remove(a1p);             // remove ( 2 4 6)
    cout << c3;                 // size should be 3, 3 dimensional, prints
                                // (0 3 0) (5 5 0) (7 0 0)

    // remove point and add to another cluster
    c2.add(c3.remove(e1p));             // removes (7 0 0) from c3, adds to c2 which has
                                        // size 2, and points (0 3 0) ( 2 4 6)

    cout << c2;                         // should print size 3 and points
                                        // (0 3 0) (2 4 6) (7 0 0)

    cout << c3;                         // should print size 2 and points
                                        // (0 3 0) (5 5 0)

/*
 * remove test case:        empty cluster
 * code asserts that size of cluster isn't zero, if it is program terminates
 */

    Cluster c4;
   // c4.remove(e1p);               // assert fails here, abort

/*
 * remove test case:        when point to be removed isn't actually in the cluster
 * cluster remains unchanged
 */

    double F1[3] = {0,0,0};
    Point f1(3,F1);
    PointPtr f1p = &f1;

    double G1[3] = {9,3,0};
    Point g1(3,G1);
    PointPtr g1p = &g1;

    c4.add(f1p);            // (0 0 0)
    c4.add(g1p);            // (9 3 0)
    c4.add(e1p);            // (7 0 0)

    cout << c4;         // should print size of 3, 3 dimensional, with points
                        // (0 0 0) (7 0 0) (9 3 0)

    c4.remove(d1p);     // trying to remove (5 5 0), makes no alterations to c4

    cout << c4;

/*  bool operator==(const Cluster &lhs, const Cluster &rhs)
 * compares two clusters, by comparing points in list
 *
 * Case 1:      clusters of same size being compared
 *
 * Case 2:      clusters of different size being compared
 *              automatically declares them not equal to to unequal size
 */

    Cluster c5(c4);                 // c5 now has size 3, 3 dimensional and contains points
                                    // (0 0 0) (7 0 0) (9 3 0)

    cout << endl << (c4 == c5) << endl;         // should print 1 since they are equal

    Cluster c6;                                  // size 0, empty cluster

    cout << endl << (c4 == c6) << endl;         // should print 0 since they are of different sizes


    // c3 currently is of size 2, with points (0 3 0) (5 5 0)
    c3.add(e1p);                    // adding (7 0 0), now of size 3 with points
                                    // (0 3 0) (5 5 0) (7 0 0)

    cout << c3;

    cout << endl << (c4 == c3) << endl;       // should print 0 since clusters contain different points



    /*  Cluster &operator+=(const Cluster &rhs); // union
     * adds contents of 1 cluster to another existing cluster
     *
     * case 1:      trying to add an empty cluster
     *              code just returns lhs cluster without any alteration
     *
     * case 2:      one cluster added to set of another
     */

    Cluster c7;                         // empty cluster

    c3 += c7;                           // attempts to add empty cluster, c3 unaltered

    cout << c3;                        // should print (0 3 0) (5 5 0) (7 0 0)


    c3 += c4;                          // c4 has size 3 w/ Points  (0 0 0) (7 0 0) (9 3 0)

    cout << c3;                         // c3 should have size 6, and Points
                                        // (0 0 0) (0 3 0) (5 5 0) (7 0 0) (7 0 0) (9 3 0)


    /* Cluster &operator-=(const Cluster &rhs)
     * removes any points both clusters share from lhs cluster
     *
     *If clusters share no points in common, lhs cluster is unchanged
     */

    c3 -= c4;                          // removes all instances of (0 0 0) (7 0 0) (9 3 0)

    cout << c3;                         // c3 should now have size 2 with points
                                        // (0 3 0) (5 5 0)


    /* Cluster &operator+=(const Point &rhs);
     * adds a point to a cluster;
     *
     */

    double M1[3] = {2,2,2};
    Point m1(3,M1);
    PointPtr m1p = &m1;

    c3 += m1;               // add (2 2 2) to c3

    cout << c3;             // c3 should have size 3 w/ points (0 3 0) (2 2 2) (5 5 0)


    /* Cluster &operator-=(const Point &rhs)
     * removes a particular point from a cluster
     *
     * if point doesn't reside in cluster, cluster remains unaltered
     */

    c3 -= d1;           // remove point (5 5 0)

    cout << c3;         // c3 should have size 2 w/ points (0 3 0) (2 2 2)

    c3 -= e1;           // attempting to remove point (7 0 0)

    cout << c3;         // c3 unchanged


    /*  friend const Cluster operator+(const Cluster &lhs, const Cluster &rhs);
     * returns a new cluster that contains all points in both lhs and rhs
     *
     * case 1:  clusters added are of different sizes
     *
     *
     * case 2:  cluster added are of same size
     *
     *In both cases , the union is successfully acheived, clusters do not
     * need to be of same size.
     */

    Cluster c8;
                            // c4 has size 3 w/ Points  (0 0 0) (7 0 0) (9 3 0)
                            // c3 has size 2 w/ Points  (0 3 0) (2 2 2)
    c8 = (c3 + c4);         // c8 should contain all of these, with size 5

    cout << c8;

    Cluster c9;

    c9 = (c3 + c3);         // c9 will have size 4 with set: (0 3 0) (0 3 0) (2 2 2) (2 2 2)

    cout << c9;


    /* friend const Cluster operator-(const Cluster &lhs, const Cluster &rhs);
     * returns a new cluster that contains all points of lhs except those also found in rhs
     *
     * if lhs and rhs have no points in common, a full copy of lhs is in new cluster
     *
     * if lhs == rhs, the new cluster will have no points and size 0
     */

    Cluster c10;

    c10 = (c9 - c9);            // c10 will be an empty cluster of size 0

    cout << c10;

    Cluster c11(c5);            // c5 now has size 3, 3 dimensional and contains points
                                  // (0 0 0) (7 0 0) (9 3 0)

    cout << c11;

    Cluster c12;
    c12.add(f1p);                 // adds point (0 0 0)

    c10 = (c11 - c12);          // c10 will has size 2 w/ points (7 0 0) (9 3 0)

    cout << c10;


    /*  friend const Cluster operator+(const Cluster &lhs, const PointPtr &rhs)
     * returns a new cluster that contains the lhs cluster plus the specified point
     *
     */

    double N1[3] = {9,10,11};
    Point n1(3,N1);
    PointPtr n1p = &n1;

    Cluster c13;

    c13 = (c10 + n1p );     // c10 is of size 2 w/ points (7 0 0) (9 3 0)

    cout << c13;            // should have size 3 and set: (7 0 0) (9 3 0) (9 10 11)


    /* friend const Cluster operator-(const Cluster &lhs, const PointPtr &rhs)
     * returns a new cluster that contains the lhs cluster minus the specified point
     *
     * if specified point doesn't exist in cluster, a full copy of lhs cluster is in new cluster
     */

    Cluster c14;

    c14 = (c13 - e1p);      // e1p is the point ( 7 0 0 )
                            // leaves the set of size 2: (9 3 0) ( 9 10 11)

    cout << c14;